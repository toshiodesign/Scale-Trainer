<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bass Scale Trainer</title>
    <style>
        /* --- CSS Variables --- */
        :root {
            --bg-body: #121212;
            --bg-app: #1E1E1E;
            --text-main: #E0E0E0;
            --text-sub: #A0A0A0;
            
            --fret-line: #444444;
            --nut-line: #888888;
            --string-line: #555555;
            --inlay: #000000;
            
            --note-root: #D35400;   /* Root: Burnt Orange */
            --note-active: #3498DB; /* Chord Tones: Blue */
            --note-extension: #9B59B6; /* Extensions: Purple */
            --note-ghost: #2C2C2C;  
            
            --note-text-active: #ffffff;
            --note-text-ghost: #555555;

            --btn-bg: #2C2C2C;
            --btn-border: #444;
            --btn-active-bg: #3498DB;
            --btn-active-text: #ffffff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow-x: hidden;
        }

        .app-container {
            width: 100%;
            max-width: 1400px;
            background: var(--bg-app);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* --- Header --- */
        .header-section {
            padding: 15px 20px;
            border-bottom: 1px solid var(--fret-line);
            background: var(--bg-app);
            z-index: 10;
            position: relative;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        h1 { margin: 0; font-size: 1.2rem; color: var(--text-main); white-space: nowrap; }
        
        .switches-area { display: flex; gap: 10px; align-items: center; }

        .controls-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            width: 100%;
            margin-top: 10px;
        }

        .control-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            flex-grow: 1;
        }

        select {
            padding: 8px;
            font-size: 0.9rem;
            border: 1px solid var(--btn-border);
            border-radius: 6px;
            background-color: var(--bg-body);
            color: var(--text-main);
            outline: none;
            min-width: 120px;
        }
        
        select optgroup {
            background-color: var(--bg-app);
            color: var(--text-sub);
            font-style: normal;
            font-weight: bold;
        }

        #exerciseModeSelect, #stringPairSelect {
            border-color: var(--note-active);
            font-weight: bold;
        }

        /* Toggles */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-body);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            user-select: none;
            border: 1px solid var(--btn-border);
        }
        
        .toggle-switch {
            position: relative;
            width: 36px;
            height: 18px;
            background-color: #555;
            border-radius: 20px;
            transition: background-color 0.3s;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        
        #multiModeCheck:checked + .toggle-switch { background-color: var(--note-active); }
        input[type="checkbox"]:checked + .toggle-switch::after { transform: translateX(18px); }

        /* --- Buttons --- */
        .pos-buttons-container {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding: 10px 15px;
            background: var(--bg-app);
            border-bottom: 1px solid var(--fret-line);
            scrollbar-width: none;
            z-index: 10;
        }
        .pos-buttons-container::-webkit-scrollbar { display: none; }

        .pos-btn {
            white-space: nowrap;
            padding: 6px 12px;
            border: 1px solid var(--btn-border);
            background: var(--btn-bg);
            color: var(--text-sub);
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.1;
            min-width: 80px;
        }
        .pos-btn span.mode-name { font-size: 0.7rem; opacity: 0.8; font-weight: normal; margin-top: 2px; }
        .pos-btn.active {
            background: var(--btn-active-bg);
            color: var(--btn-active-text);
            border-color: var(--btn-active-bg);
            font-weight: 600;
        }

        /* --- Fretboard Container --- */
        .fretboard-wrapper {
            width: 100%;
            height: 60vh; 
            min-height: 300px;
            background: var(--bg-app);
            /* 改為 relative，不再需要 transform layer */
            position: relative;
            overflow: hidden;
            touch-action: none; /* 禁止瀏覽器預設滾動，完全接管 */
            cursor: grab;
        }
        
        .fretboard-wrapper:active {
            cursor: grabbing;
        }

        svg {
            display: block;
            width: 100%; 
            height: 100%; /* SVG 佔滿容器，內容由 viewBox 控制 */
            pointer-events: none; /* 讓事件穿透到 wrapper 處理 */
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 15px;
            padding: 10px 15px;
            font-size: 0.75rem;
            background: var(--bg-body);
            border-top: 1px solid var(--fret-line);
            justify-content: center;
            flex-wrap: wrap;
            color: var(--text-sub);
            z-index: 10;
        }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }
        
        .note-text { 
            font-family: Arial, sans-serif; 
            font-weight: bold; 
            font-size: 10px; 
            pointer-events: none; 
            /* 讓文字在縮放時保持清晰 */
            text-rendering: geometricPrecision; 
        }

        /* Reset Button */
        .reset-zoom-btn {
            position: absolute;
            bottom: 60px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            z-index: 20;
        }
        .reset-zoom-btn:hover { background: var(--btn-active-bg); }

    </style>
</head>
<body>

    <div class="app-container">
        <div class="header-section">
            <div class="header-top">
                <h1>Bass Scale Trainer</h1>
                <div class="switches-area">
                    <label class="toggle-container">
                        <input type="checkbox" id="multiModeCheck" onchange="toggleMultiMode()">
                        <div class="toggle-switch"></div>
                        <span>Multi Select</span>
                    </label>
                </div>
            </div>
            
            <div class="controls-row">
                <select id="exerciseModeSelect" onchange="toggleExerciseMode()">
                    <option value="scale">模式: 全指板音階 (Scale/Chord)</option>
                    <option value="pair_drill" selected>模式: 雙弦模進練習 (2-String Drill)</option>
                </select>

                <div class="control-group">
                    <select id="keySelect" onchange="resetAndUpdate()">
                        <option value="0">Key: C</option>
                        <option value="1">Key: Db</option>
                        <option value="2">Key: D</option>
                        <option value="3">Key: Eb</option>
                        <option value="4">Key: E</option>
                        <option value="5">Key: F</option>
                        <option value="6">Key: Gb</option>
                        <option value="7">Key: G</option>
                        <option value="8">Key: Ab</option>
                        <option value="9">Key: A</option>
                        <option value="10">Key: Bb</option>
                        <option value="11">Key: B</option>
                    </select>

                    <select id="scaleSelect" onchange="resetAndUpdate()">
                        <optgroup label="Basic Scales">
                            <option value="major">Scale: Major (Ionian)</option>
                            <option value="minor">Scale: Natural Minor</option>
                            <option value="maj_pent">Scale: Major Pentatonic</option>
                            <option value="min_pent">Scale: Minor Pentatonic</option>
                        </optgroup>
                        <optgroup label="Triads">
                            <option value="maj_triad">Chord: Major Triad</option>
                            <option value="min_triad">Chord: Minor Triad</option>
                            <option value="aug_triad">Chord: Augmented</option>
                            <option value="dim_triad">Chord: Diminished</option>
                        </optgroup>
                        <optgroup label="7th Chords">
                            <option value="maj7">Chord: Major 7</option>
                            <option value="min7">Chord: Minor 7</option>
                            <option value="dom7">Chord: Dominant 7</option>
                            <option value="m7b5">Chord: Min7(b5)</option>
                            <option value="dim7">Chord: Diminished 7</option>
                        </optgroup>
                        <optgroup label="Extended Chords">
                            <option value="maj9">Chord: Maj 9 (R,3,5,7,9)</option>
                            <option value="min9">Chord: Min 9 (R,b3,5,b7,9)</option>
                            <option value="dom9">Chord: Dom 9 (R,3,5,b7,9)</option>
                            <option value="maj7_sharp11">Chord: Maj7(#11) Lydian</option>
                            <option value="dom13">Chord: Dom 13 (Funk)</option>
                        </optgroup>
                    </select>

                    <select id="stringPairSelect" class="hidden" onchange="resetAndUpdate()">
                        <option value="0,1">練習: G & D Strings (High)</option>
                        <option value="1,2">練習: D & A Strings</option>
                        <option value="2,3">練習: A & E Strings</option>
                        <option value="3,4" selected>練習: E & B Strings (Low)</option>
                    </select>

                    <select id="viewModeSelect" onchange="updateApp()">
                        <option value="notes">顯示: 音名 (Notes)</option>
                        <option value="solfege" selected>顯示: 唱名 (Do Re Mi)</option>
                        <option value="intervals">顯示: 級數 (Root/#11/13)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="pos-buttons-container" id="posBtnContainer"></div>

        <div class="fretboard-wrapper" id="zoomContainer">
            <svg id="fretboard" viewBox="0 0 1650 240" preserveAspectRatio="xMidYMid meet">
            </svg>
        </div>
        <button class="reset-zoom-btn" onclick="resetView()">Reset View</button>

        <div class="legend">
            <div class="legend-item"><span class="dot" style="background:var(--note-root)"></span>根音 (Root)</div>
            <div class="legend-item"><span class="dot" style="background:var(--note-active)"></span>組成音 (Chord Tones)</div>
            <div class="legend-item"><span class="dot" style="background:var(--note-extension)"></span>延伸音 (9 / 11 / 13)</div>
        </div>
    </div>

<script>
    const FRETS = 24;
    const TUNING = [7, 2, 9, 4, 11]; // G, D, A, E, B
    const STRINGS = 5;

    // SVG Base Dimensions
    const BASE_W = 1650;
    const BASE_H = 240;
    const X_START = 50;
    const Y_START = 30;
    const FRET_WIDTH = 65;
    const STRING_GAP = 40;

    const NOTES_FLAT =  ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
    const NOTES_SHARP = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    const SCALES = {
        'major':    [0, 2, 4, 5, 7, 9, 11],
        'minor':    [0, 2, 3, 5, 7, 8, 10],
        'maj_pent': [0, 2, 4, 7, 9],
        'min_pent': [0, 3, 5, 7, 10],
        'maj_triad': [0, 4, 7],
        'min_triad': [0, 3, 7],
        'aug_triad': [0, 4, 8],
        'dim_triad': [0, 3, 6],
        'maj7':     [0, 4, 7, 11],
        'min7':     [0, 3, 7, 10],
        'dom7':     [0, 4, 7, 10],
        'm7b5':     [0, 3, 6, 10],
        'dim7':     [0, 3, 6, 9],
        'maj9':     [0, 2, 4, 7, 11],
        'min9':     [0, 2, 3, 7, 10],
        'dom9':     [0, 2, 4, 7, 10],
        'maj7_sharp11': [0, 2, 4, 6, 7, 11], 
        'dom13':    [0, 2, 4, 7, 9, 10]
    };

    const INTERVAL_NAMES = {
        'major':    ['R', '2', '3', '4', '5', '6', '7'],
        'minor':    ['R', '2', 'b3', '4', '5', 'b6', 'b7'],
        'maj_pent': ['R', '2', '3', '5', '6'],
        'min_pent': ['R', 'b3', '4', '5', 'b7'],
        'maj_triad': ['R', '3', '5'],
        'min_triad': ['R', 'b3', '5'],
        'aug_triad': ['R', '3', '#5'],
        'dim_triad': ['R', 'b3', 'b5'],
        'maj7':     ['R', '3', '5', '7'],
        'min7':     ['R', 'b3', '5', 'b7'],
        'dom7':     ['R', '3', '5', 'b7'],
        'm7b5':     ['R', 'b3', 'b5', 'b7'],
        'dim7':     ['R', 'b3', 'b5', 'bb7'],
        'maj9':     ['R', '9', '3', '5', '7'],
        'min9':     ['R', '9', 'b3', '5', 'b7'],
        'dom9':     ['R', '9', '3', '5', 'b7'],
        'maj7_sharp11': ['R', '9', '3', '#11', '5', '7'], 
        'dom13':    ['R', '9', '3', '5', '13', 'b7']
    };
    
    const CN_INTERVAL_MAP = {
        'R': '純1',
        'b2': '小2', '2': '大2',
        'b3': '小3', '3': '大3',
        '4': '純4', '#4': '增4', 'b5': '減5',
        '5': '純5', '#5': '增5',
        'b6': '小6', '6': '大6',
        'b7': '小7', 'bb7': '減7', '7': '大7',
        '9': '大9', 'b9': '小9', '#9': '增9',
        '11': '純11', '#11': '增11',
        '13': '大13', 'b13': '小13'
    };
    
    const SOLFEGE_MAP = {
        'R': 'Do', '2': 'Re', '3': 'Mi', 'b3': 'Me', 
        '4': 'Fa', '#4': 'Fi', 'b5': 'Se', 
        '5': 'So', '#5': 'Si',
        '6': 'La', 'b6': 'Le', 
        '7': 'Si', 'b7': 'Te', 'bb7': 'La',
        '9': 'Re', 'b9': 'Ra', '#9': 'Ri',
        '11': 'Fa', '#11': 'Fi',
        '13': 'La', 'b13': 'Le'
    };

    const SCALE_MODE_NAMES = {
        'major': ["Ionian", "Dorian", "Phrygian", "Lydian", "Mixolydian", "Aeolian", "Locrian"],
        'minor': ["Aeolian", "Locrian", "Ionian", "Dorian", "Phrygian", "Lydian", "Mixo"],
        'maj_pent': ["Shape 1", "Shape 2", "Shape 3", "Shape 4", "Shape 5"],
        'min_pent': ["Shape 1", "Shape 2", "Shape 3", "Shape 4", "Shape 5"],
        
        'maj_triad': ["Root Pos", "1st Inv", "2nd Inv"],
        'min_triad': ["Root Pos", "1st Inv", "2nd Inv"],
        'aug_triad': ["Root Pos", "1st Inv", "2nd Inv"],
        'dim_triad': ["Root Pos", "1st Inv", "2nd Inv"],
        
        'maj7': ["Root Pos", "1st Inv", "2nd Inv", "3rd Inv"],
        'min7': ["Root Pos", "1st Inv", "2nd Inv", "3rd Inv"],
        'dom7': ["Root Pos", "1st Inv", "2nd Inv", "3rd Inv"],
        'm7b5': ["Root Pos", "1st Inv", "2nd Inv", "3rd Inv"],
        'dim7': ["Root Pos", "1st Inv", "2nd Inv", "3rd Inv"],

        'maj9': ["Pos 1", "Pos 2", "Pos 3", "Pos 4", "Pos 5"],
        'min9': ["Pos 1", "Pos 2", "Pos 3", "Pos 4", "Pos 5"],
        'dom9': ["Pos 1", "Pos 2", "Pos 3", "Pos 4", "Pos 5"],
        'maj7_sharp11': ["Pos 1", "Pos 2", "Pos 3", "Pos 4", "Pos 5", "Pos 6"],
        'dom13': ["Pos 1", "Pos 2", "Pos 3", "Pos 4", "Pos 5", "Pos 6"]
    };

    let currentRoot = 0;
    let currentScaleType = 'major';
    let currentViewMode = 'solfege';
    let exerciseMode = 'pair_drill'; 
    let selectedPair = [3, 4];

    let activeAnchors = new Set([]); 
    let generatedPositions = []; 
    let isMultiMode = false;

    // --- Core Logic ---

    function getNoteValue(stringIdx, fret) {
        return (TUNING[stringIdx] + fret) % 12;
    }

    function getNoteName(val, interval) {
        if (interval && interval.includes('#')) return NOTES_SHARP[val];
        if (interval && interval.includes('b')) return NOTES_FLAT[val];
        return NOTES_FLAT[val];
    }

    function getIntervalLabel(noteVal) {
        let type = (exerciseMode === 'pair_drill') ? 'major' : currentScaleType;
        const scaleIntervals = SCALES[type];
        const scaleNotes = scaleIntervals.map(i => (parseInt(currentRoot) + i) % 12);
        
        const idx = scaleNotes.indexOf(noteVal);
        if (idx !== -1) {
            return INTERVAL_NAMES[type][idx];
        }
        return null;
    }

    function getSolfegeLabel(noteVal) {
        let interval = getIntervalLabel(noteVal);
        return SOLFEGE_MAP[interval] || interval || "?";
    }

    function generateDynamicPositions(scaleNotes) {
        let positions = [];
        let bStringBase = TUNING[4]; 
        let modeNames = SCALE_MODE_NAMES[currentScaleType];
        
        for (let f = 0; f <= 22; f++) {
            let noteVal = (bStringBase + f) % 12;
            let scaleIndex = scaleNotes.indexOf(noteVal);
            
            if (scaleIndex !== -1) {
                let modeName = modeNames[scaleIndex % modeNames.length];
                positions.push({
                    anchorFret: f, 
                    noteVal: noteVal,
                    modeName: modeName,
                    id: f
                });
            }
        }
        return positions;
    }

    function generatePairDrillPositions() {
        let positions = [];
        let scaleIntervals = SCALES['major']; 
        let scaleNotes = scaleIntervals.map(i => (parseInt(currentRoot) + i) % 12);
        let modeNames = SCALE_MODE_NAMES['major'];

        let sHigh = Math.min(...selectedPair);
        let sLow = Math.max(...selectedPair);

        // Fill to 24 Frets
        for (let f = 0; f <= FRETS; f++) {
            let noteVal = getNoteValue(sLow, f);
            let scaleIdx = scaleNotes.indexOf(noteVal); 

            if (scaleIdx !== -1) {
                let stepNotes = [];
                const findFret = (s, startFret, targetDegreeIdx) => {
                    let targetVal = scaleNotes[targetDegreeIdx % 7];
                    for(let i=0; i<6; i++) {
                        let tryFret = startFret + i;
                        if (tryFret > FRETS) continue;
                        if (getNoteValue(s, tryFret) === targetVal) return tryFret;
                    }
                    return -1;
                };

                let validSequence = true;
                let currentFret = f;
                
                for(let i=0; i<3; i++) {
                    let fret = findFret(sLow, (i===0?f:currentFret), scaleIdx + i);
                    if(fret === -1) { validSequence = false; break; }
                    stepNotes.push({ s: sLow, fret: fret, val: getNoteValue(sLow, fret) });
                    currentFret = fret;
                }

                let highStringStartSearch = f; 
                currentFret = highStringStartSearch;

                if (validSequence) {
                    for(let i=0; i<3; i++) {
                        let fret = findFret(sHigh, (i===0?highStringStartSearch:currentFret), scaleIdx + 3 + i);
                        if(fret === -1) { validSequence = false; break; }
                        stepNotes.push({ s: sHigh, fret: fret, val: getNoteValue(sHigh, fret) });
                        currentFret = fret;
                    }
                }

                if (validSequence) {
                    let solfegeStart = SOLFEGE_MAP[INTERVAL_NAMES['major'][scaleIdx]];
                    positions.push({
                        id: f, 
                        label: `Start: ${solfegeStart}`,
                        subLabel: modeNames[scaleIdx],
                        notes: stepNotes
                    });
                }
            }
        }
        return positions;
    }

    function getNotesForAnchor(anchorId, scaleNotes) {
        if (exerciseMode === 'pair_drill') {
            let pos = generatedPositions.find(p => p.id === anchorId);
            if (!pos) return [];
            return pos.notes.map(n => ({
                s: n.s,
                fret: n.fret,
                val: n.val,
                isRoot: n.val === parseInt(currentRoot)
            }));
        } else {
            let anchorFret = anchorId;
            let activeNotes = [];
            let notesPerOctave = scaleNotes.length;
            let currentStringStart = anchorFret; 
            let isOpenMode = (anchorFret === 0);

            for (let s = 4; s >= 0; s--) {
                let stringBase = TUNING[s];
                let notesFoundOnString = [];
                let searchWidth = 5; 
                
                let minFret, maxFret;

                if (isOpenMode) {
                    minFret = 0;
                    maxFret = 4;
                } else {
                    minFret = Math.max(0, currentStringStart);
                    maxFret = minFret + searchWidth;
                }
                if (maxFret > FRETS) maxFret = FRETS;

                for (let f = minFret; f <= maxFret; f++) {
                    let val = (stringBase + f) % 12;
                    if (scaleNotes.includes(val)) {
                        notesFoundOnString.push({
                            s: s,
                            fret: f,
                            val: val,
                            isRoot: val === parseInt(currentRoot)
                        });
                    }
                }

                let countToTake = 3; 
                let chosen = notesFoundOnString.slice(0, countToTake);

                chosen.forEach(n => {
                    activeNotes.push({
                        s: n.s,
                        fret: n.fret,
                        val: n.val,
                        isRoot: n.isRoot
                    });
                });

                if (chosen.length > 0) {
                    if (isOpenMode) {
                        currentStringStart = 0;
                    } else {
                        let firstFret = chosen[0].fret;
                        if (firstFret === 0 && chosen.length > 1) firstFret = chosen[1].fret;
                        currentStringStart = firstFret;
                    }
                }
            }
            return activeNotes;
        }
    }

    // --- Interaction ---
    function toggleMultiMode() {
        const checkbox = document.getElementById('multiModeCheck');
        isMultiMode = checkbox.checked;
        if (!isMultiMode && activeAnchors.size > 1) {
            const first = activeAnchors.values().next().value;
            activeAnchors.clear();
            activeAnchors.add(first);
        }
        updateApp();
    }

    function toggleExerciseMode() {
        exerciseMode = document.getElementById('exerciseModeSelect').value;
        const scaleSelect = document.getElementById('scaleSelect');
        const pairSelect = document.getElementById('stringPairSelect');

        if (exerciseMode === 'pair_drill') {
            scaleSelect.classList.add('hidden');
            pairSelect.classList.remove('hidden');
            currentScaleType = 'major'; 
        } else {
            scaleSelect.classList.remove('hidden');
            pairSelect.classList.add('hidden');
            currentScaleType = scaleSelect.value;
        }
        resetAndUpdate();
    }

    function resetAndUpdate() {
        currentRoot = parseInt(document.getElementById('keySelect').value);
        
        if (exerciseMode === 'scale') {
            currentScaleType = document.getElementById('scaleSelect').value;
            const scaleIntervals = SCALES[currentScaleType];
            const scaleNotes = scaleIntervals.map(i => (parseInt(currentRoot) + i) % 12);
            generatedPositions = generateDynamicPositions(scaleNotes);
        } else {
            let pairVal = document.getElementById('stringPairSelect').value.split(',').map(Number);
            selectedPair = pairVal;
            generatedPositions = generatePairDrillPositions();
        }
        
        if (!isMultiMode || activeAnchors.size === 0) {
            activeAnchors.clear();
            if(generatedPositions.length > 0) activeAnchors.add(generatedPositions[0].id);
        }
        updateApp();
    }

    function handlePosClick(id) {
        if (isMultiMode) {
            if (activeAnchors.has(id)) activeAnchors.delete(id);
            else activeAnchors.add(id);
        } else {
            activeAnchors.clear();
            activeAnchors.add(id);
        }
        updateApp();
    }

    function updateApp() {
        currentViewMode = document.getElementById('viewModeSelect').value;
        let scaleIntervals = SCALES['major'];
        if (exerciseMode === 'scale') scaleIntervals = SCALES[currentScaleType];
        
        const scaleNotes = scaleIntervals.map(i => (parseInt(currentRoot) + i) % 12);

        const btnContainer = document.getElementById('posBtnContainer');
        btnContainer.innerHTML = '';
        
        generatedPositions.forEach((pos, idx) => {
            let btn = document.createElement('button');
            btn.className = 'pos-btn';
            if (activeAnchors.has(pos.id)) btn.classList.add('active');
            
            if (exerciseMode === 'scale') {
                let label = (pos.id === 0) ? "Open" : `Pos ${idx + 1}`;
                btn.innerHTML = `${label}<span class="mode-name">${pos.modeName}</span>`;
            } else {
                btn.innerHTML = `${pos.label}<span class="mode-name">${pos.subLabel}</span>`;
            }
            
            btn.onclick = () => handlePosClick(pos.id);
            btnContainer.appendChild(btn);
        });

        drawFretboard(scaleNotes);
    }

    function drawFretboard(scaleNotes) {
        const svg = document.getElementById('fretboard');
        svg.innerHTML = '';

        for (let f = 0; f <= FRETS; f++) {
            let x = X_START + (f * FRET_WIDTH);
            let isNut = (f === 0);
            
            let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x); line.setAttribute("y1", Y_START);
            line.setAttribute("x2", x); line.setAttribute("y2", Y_START + 4 * STRING_GAP);
            line.setAttribute("stroke", isNut ? "var(--nut-line)" : "var(--fret-line)");
            line.setAttribute("stroke-width", isNut ? 5 : 2);
            svg.appendChild(line);

            if (f > 0) {
                let txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                txt.setAttribute("x", x - FRET_WIDTH/2);
                txt.setAttribute("y", Y_START - 10);
                txt.setAttribute("text-anchor", "middle");
                txt.setAttribute("fill", "var(--text-sub)");
                txt.setAttribute("font-size", "12");
                txt.textContent = f;
                svg.appendChild(txt);
            }

            let cx = x - FRET_WIDTH/2;
            let cy = Y_START + 2 * STRING_GAP;
            if ([3,5,7,9,15,17,19,21].includes(f)) drawInlay(svg, cx, cy, false);
            if ([12, 24].includes(f)) drawInlay(svg, cx, cy, true);
        }

        for (let s = 0; s < STRINGS; s++) {
            let y = Y_START + (s * STRING_GAP);
            let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", X_START); line.setAttribute("y1", y);
            line.setAttribute("x2", X_START + (FRETS * FRET_WIDTH)); line.setAttribute("y2", y);
            line.setAttribute("stroke", "var(--string-line)");
            line.setAttribute("stroke-width", 1 + s * 0.5);
            svg.appendChild(line);
        }

        if (exerciseMode === 'scale') {
            for (let s = 0; s < STRINGS; s++) {
                for (let f = 0; f <= FRETS; f++) {
                    let val = getNoteValue(s, f);
                    if (scaleNotes.includes(val)) {
                        drawNoteCircle(svg, s, f, val, false);
                    }
                }
            }
        } else {
            selectedPair.forEach(s => {
                for (let f = 0; f <= FRETS; f++) {
                    let val = getNoteValue(s, f);
                    if (scaleNotes.includes(val)) {
                        drawNoteCircle(svg, s, f, val, false);
                    }
                }
            });
        }

        let mergedActiveNotes = new Map();
        activeAnchors.forEach(anchorId => {
            let notes = getNotesForAnchor(anchorId, scaleNotes);
            notes.forEach(n => {
                let key = `${n.s}-${n.fret}`;
                if (!mergedActiveNotes.has(key) || n.isRoot) {
                    mergedActiveNotes.set(key, n);
                }
            });
        });

        mergedActiveNotes.forEach(n => {
            if (n.fret <= FRETS) {
                drawNoteCircle(svg, n.s, n.fret, n.val, true);
            }
        });
    }

    function drawInlay(svg, cx, cy, isDouble) {
        if (isDouble) {
            createCircle(svg, cx, cy - 15, 5, "var(--inlay)");
            createCircle(svg, cx, cy + 15, 5, "var(--inlay)");
        } else {
            createCircle(svg, cx, cy, 5, "var(--inlay)");
        }
    }

    function createCircle(svg, cx, cy, r, fill) {
        let c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", r);
        c.setAttribute("fill", fill);
        svg.appendChild(c);
    }

    function drawNoteCircle(svg, s, f, val, isActive) {
        let cx = X_START + (f * FRET_WIDTH) - (FRET_WIDTH/2);
        if (f === 0) cx = X_START - 20;

        let cy = Y_START + (s * STRING_GAP);
        let g = document.createElementNS("http://www.w3.org/2000/svg", "g");

        let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", cx);
        circle.setAttribute("cy", cy);
        
        let isRoot = (val === parseInt(currentRoot));
        
        let intervalLabel = getIntervalLabel(val);
        let isExtension = ['9', '11', '#11', '13', 'b9', '#9', 'b13'].includes(intervalLabel);

        if (isActive) {
            circle.setAttribute("r", 14);
            let color;
            if (isRoot) color = "var(--note-root)";
            else if (isExtension) color = "var(--note-extension)";
            else color = "var(--note-active)";
            
            circle.setAttribute("fill", color);
            circle.setAttribute("stroke", "var(--bg-app)");
            circle.setAttribute("stroke-width", 2);
        } else {
            circle.setAttribute("r", 8);
            circle.setAttribute("fill", "var(--note-ghost)"); 
        }
        g.appendChild(circle);

        if (isActive || f === 0) {
            let txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
            txt.setAttribute("x", cx);
            txt.setAttribute("y", cy + 1);
            txt.setAttribute("dominant-baseline", "central");
            txt.setAttribute("text-anchor", "middle");
            txt.setAttribute("class", "note-text");
            txt.setAttribute("fill", isActive ? "var(--note-text-active)" : "var(--note-text-ghost)");
            
            let labelText = "";
            if (currentViewMode === 'notes') {
                labelText = getNoteName(val, intervalLabel);
            } else if (currentViewMode === 'solfege') {
                labelText = getSolfegeLabel(val);
            } else {
                let rawInterval = getIntervalLabel(val);
                labelText = CN_INTERVAL_MAP[rawInterval] || rawInterval || "?";
            }
            
            txt.textContent = labelText;
            g.appendChild(txt);
        }
        
        svg.appendChild(g);
    }

    // --- VECTOR ZOOM ENGINE (ViewBox Manipulation) ---
    const zoomContainer = document.getElementById('zoomContainer');
    const svgElement = document.getElementById('fretboard');

    // Current ViewBox State
    let viewBox = { x: 0, y: 0, w: BASE_W, h: BASE_H };
    
    // Limits
    const MAX_W = BASE_W;
    const MIN_W = BASE_W / 4; // Max 4x zoom
    
    function setViewBox() {
        // Constraints Check
        if (viewBox.w > MAX_W) viewBox.w = MAX_W;
        if (viewBox.w < MIN_W) viewBox.w = MIN_W;
        if (viewBox.h > BASE_H) viewBox.h = BASE_H;
        
        // Keep Ratio locked (width drives height)
        // Ratio = 1650 / 240 = 6.875
        viewBox.h = viewBox.w * (BASE_H / BASE_W);

        // Pan Constraints
        if (viewBox.x < 0) viewBox.x = 0;
        if (viewBox.y < 0) viewBox.y = 0;
        if (viewBox.x + viewBox.w > BASE_W) viewBox.x = BASE_W - viewBox.w;
        if (viewBox.y + viewBox.h > BASE_H) viewBox.y = BASE_H - viewBox.h;

        svgElement.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
    }

    function resetView() {
        viewBox = { x: 0, y: 0, w: BASE_W, h: BASE_H };
        setViewBox();
    }

    // --- Touch Logic ---
    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let initialPinchDist = 0;
    let initialViewBoxW = 0;

    zoomContainer.addEventListener('mousedown', e => {
        isPanning = true;
        startX = e.clientX;
        startY = e.clientY;
        zoomContainer.style.cursor = 'grabbing';
    });

    zoomContainer.addEventListener('mousemove', e => {
        if (!isPanning) return;
        e.preventDefault();
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        // Convert screen pixels to SVG units
        // Ratio = Current ViewBox Width / Container CSS Width
        const containerW = zoomContainer.clientWidth;
        const ratio = viewBox.w / containerW;

        viewBox.x -= dx * ratio;
        viewBox.y -= dy * ratio;

        startX = e.clientX;
        startY = e.clientY;
        setViewBox();
    });

    zoomContainer.addEventListener('mouseup', () => {
        isPanning = false;
        zoomContainer.style.cursor = 'grab';
    });
    
    zoomContainer.addEventListener('mouseleave', () => {
        isPanning = false;
        zoomContainer.style.cursor = 'grab';
    });

    // Touch Support
    zoomContainer.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
            isPanning = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            isPanning = false;
            initialPinchDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            initialViewBoxW = viewBox.w;
        }
    });

    zoomContainer.addEventListener('touchmove', e => {
        e.preventDefault(); // Stop page scrolling
        
        if (e.touches.length === 1 && isPanning) {
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY;
            
            const containerW = zoomContainer.clientWidth;
            const ratio = viewBox.w / containerW;

            viewBox.x -= dx * ratio;
            viewBox.y -= dy * ratio;
            
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            setViewBox();
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            
            // Zoom Factor
            const zoomChange = initialPinchDist / dist; 
            const newW = initialViewBoxW * zoomChange;

            // Simple Center Zoom approximation for smoothness
            // Calculate center shift later if needed, now keeping left-top stable logic for stability
            // Or better: zoom towards center
            
            const oldW = viewBox.w;
            viewBox.w = newW;
            
            // Adjust X to zoom into center roughly
            const diffW = oldW - viewBox.w;
            viewBox.x += diffW / 2;
            
            setViewBox();
        }
    });

    zoomContainer.addEventListener('touchend', () => {
        isPanning = false;
    });

    // Mouse Wheel Zoom
    zoomContainer.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const direction = e.deltaY > 0 ? 1 : -1; // Down = Zoom Out, Up = Zoom In
        
        const oldW = viewBox.w;
        let newW = viewBox.w * (1 + direction * zoomIntensity);
        
        // Constraint calculation handled in setViewBox, but need pre-calc for centering
        if (newW < MIN_W) newW = MIN_W;
        if (newW > MAX_W) newW = MAX_W;

        // Mouse Point Zoom Logic
        // Calculate mouse position relative to SVG
        const rect = zoomContainer.getBoundingClientRect();
        const offsetX = e.clientX - rect.left; // Pixel X in container
        
        const ratioW = oldW / rect.width; // SVG units per pixel
        const mouseSVGX = viewBox.x + offsetX * ratioW;
        
        viewBox.w = newW;
        
        // New Ratio
        const newRatioW = newW / rect.width;
        // Shift viewBox.x so that mouseSVGX remains under mouse
        viewBox.x = mouseSVGX - offsetX * newRatioW;

        setViewBox();
    }, { passive: false });

    // Init
    resetAndUpdate();
</script>
</body>
</html>
